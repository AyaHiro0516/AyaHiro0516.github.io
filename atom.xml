<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>AYAHIRO&#39;S BLOG</title>
  
  <subtitle>Nothing fxck you harder than time.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-07-14T08:25:24.819Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ayahiro</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式之工厂模式：简单工厂&amp;工厂方法&amp;抽象工厂</title>
    <link href="http://yoursite.com/2019/07/14/factory/"/>
    <id>http://yoursite.com/2019/07/14/factory/</id>
    <published>2019-07-14T08:16:47.293Z</published>
    <updated>2019-07-14T08:25:24.819Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>设计模式有3大类，分为：<strong>创建型模式</strong>、<strong>结构型模式</strong>和<strong>行为型模式</strong>。工厂模式属于创建型模式，创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。<br><a id="more"></a></p><h3 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h3><p><strong>描述：定义一个类用于创建父类相同的子类对象，由传入参数决定创建哪个子类。</strong><br><img src="/2019/07/14/factory/简单工厂.jpg" alt="简单工厂"><br>举个例子，我喜欢玩游戏。定义一个Game接口，让具体的游戏去实现这个接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeartStone</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炉石传说，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gwent</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"昆特牌，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在我们要开始玩了<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = <span class="keyword">new</span> HeartStone();</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在假设我们的程序是个大型系统，提供游戏启动的代理功能，一开始我们玩的是炉石传说，因此项目中有很多地方的代码都使用 Game game = new HeartStone(); 这样的语句来启动游戏。<br>某天，我觉得炉石传说随机性太大了，辣鸡炉石！咱们去玩昆特牌吧！那么问题来了，想更换启动的游戏，我就得将整个系统的每一处Game game = new HeartStone(); 改成 Game game = new Gwent(); 可见工作量是十分庞大的。<br>简单工厂模式就是为了解决这类问题的：具体玩什么游戏应该是随时变动的需求，不应该在程序中写死具体实例化哪个游戏子类。<br>现在添加一个游戏工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HeartStone = <span class="string">"HeartStone"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String Gwent = <span class="string">"Gwent"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Game <span class="title">playGame</span><span class="params">(String game)</span> </span>&#123;</span><br><span class="line">        Game myGame = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (game) &#123;</span><br><span class="line">            <span class="keyword">case</span> HeartStone:</span><br><span class="line">                myGame = <span class="keyword">new</span> HeartStone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Gwent:</span><br><span class="line">                myGame = <span class="keyword">new</span> Gwent();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> myGame;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主程序改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Game game = GameFactory.playGame(<span class="string">"Gwent"</span>);</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们想启动什么游戏，只需要改动playGame中的参数，而这个参数是一个字符串变量，这就意味着，我们还可以以配置文件的方式为这个字符串变量赋值，最终做到，不改动任何一处代码，只修改配置文件中的游戏信息，就可以切换具体实例化哪个游戏。</p><p>简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断(switch)，根据客户端的选择动态实例化相关的 类，对于客户端来说，去除了与具体产品的依赖。</p><h3 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h3><p><strong>描述：定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的初始化下放到子类。</strong><br><img src="/2019/07/14/factory/工厂方法.jpg" alt="工厂方法"><br>在简单工厂模式中，我们发现在添加子类的时候，相应的也需要在工厂类中添加一个判断分支(多加一个case)，是违背了开放-封闭原则的。而工厂方法模式就是主要解决这个问题的。</p><blockquote><p>开放-封闭原则：软件实体(类、模块、函数等)应该可以扩展，但是不可修改。</p></blockquote><p>回到玩游戏的例子，现在我又想玩LOL了，现在我需要添加一个LOL类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOL</span> <span class="keyword">implements</span> <span class="title">Game</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"英雄联盟，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在简单工厂模式下，还需要改动GameFactory的代码，添加一个Case,这样修改了源代码，违背了开闭原则。现在将简单工厂模式改成工厂方法模式，把GameFactory改成接口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">Game <span class="title">playGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeartStoneFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeartStone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GwentFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gwent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>这样，想添加LOL这个游戏，只需要再添加一个工厂类即可，不用<strong>修改</strong>代码，而是<strong>扩展</strong>代码。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LOLFactory</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Game <span class="title">playGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主程序为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GameFactory gameFactory = <span class="keyword">new</span> LOLFactory();</span><br><span class="line">        Game game = gameFactory.playGame();</span><br><span class="line">        game.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到使用工厂方法模式之后，扩展性变高了，如果想增加一个游戏，只要扩展一个游戏工厂类就可以。但是随之而来的是在系统中增加了复杂度，每增加一个游戏时，都需要增加一个游戏类和工厂类。</p><h3 id="抽象工厂"><a href="#抽象工厂" class="headerlink" title="抽象工厂"></a>抽象工厂</h3><p><strong>描述：为一个产品族提供了统一的创建接口。当需要这个产品族的某一系列的时候，可以从抽象工厂中选出相应的系列创建一个具体的工厂类。</strong><br><img src="/2019/07/14/factory/抽象工厂.png" alt="抽象工厂"><br>抽象工厂模式是一种特殊的工厂方法模式。在上面的玩游戏例子中，游戏工厂接口(GameFactory)的子类，只实例化一种游戏父类(Game)。这时工厂方法模式就可以满足需求。但我们知道，游戏是分为很多种类型的，如MOBA、RPG、TCG等等。<br>现在我们把Game接口拆分成RPGGame接口和CardGame接口，需求变为：GameFactory的子类可以实例化多种游戏父类了(RPGGame、CardGame)。这时候就要用到抽象工厂模式。</p><p>原先我们讨论游戏时，说的是一个很宽泛的概念，我只知道你想玩游戏，不知道你想玩什么类型的游戏。现在给你两个选项：角色扮演游戏和卡牌游戏。有两家知名游戏厂商，波兰蠢驴和暴雪，他们都有角色扮演类游戏和卡牌类游戏。<br>那么众所周知，蠢驴的RPG游戏有巫师系列，卡牌游戏是昆特牌，暴雪的RPG游戏有魔兽世界，卡牌游戏有炉石传说。这些具体的游戏都叫做<strong>产品</strong> 而游戏这个大类则是<strong>产品族</strong>，巫师和昆特牌是蠢驴的产品族；魔兽世界和炉石传说是暴雪的产品族。<br>抽象工厂模式就是描述它们之间的关系的：将同一类的产品子类归为一类，让他们继承同一个接口，(巫师和魔兽世界都是RPG，让它们都继承RPG接口)，然后将不同类的产品归为一族，让不同类的产品都可以被一个工厂子类实例化(魔兽世界和炉石传说是不同类的游戏，但都可以被暴雪公司实例化)。<br>通过代码直观展示：<br>游戏类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">RPGGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CardGame</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">play</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeartStone</span> <span class="keyword">implements</span> <span class="title">CardGame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"炉石传说，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Gwent</span> <span class="keyword">implements</span> <span class="title">CardGame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"昆特牌，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WOW</span> <span class="keyword">implements</span> <span class="title">RPGGame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"魔兽世界，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Witcher</span> <span class="keyword">implements</span> <span class="title">RPGGame</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">play</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"巫师，启动！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>游戏工厂类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="function">RPGGame <span class="title">playRPGGame</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">CardGame <span class="title">playCardGame</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CDProjektRed</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RPGGame <span class="title">playRPGGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Witcher();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CardGame <span class="title">playCardGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Gwent();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Blizzard</span> <span class="keyword">implements</span> <span class="title">GameFactory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RPGGame <span class="title">playRPGGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> WOW();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CardGame <span class="title">playCardGame</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> HeartStone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>主程序<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        GameFactory gameFactory1 = <span class="keyword">new</span> CDProjektRed();</span><br><span class="line">        GameFactory gameFactory2 = <span class="keyword">new</span> Blizzard();</span><br><span class="line">        RPGGame game1 = gameFactory1.playRPGGame();</span><br><span class="line">        CardGame game2 = gameFactory1.playCardGame();</span><br><span class="line">        RPGGame game3 = gameFactory2.playRPGGame();</span><br><span class="line">        CardGame game4 = gameFactory2.playCardGame();</span><br><span class="line">        game1.play();</span><br><span class="line">        game2.play();</span><br><span class="line">        game3.play();</span><br><span class="line">        game4.play();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>现在，我们的游戏启动代理系统的功能就被进一步完善了，如果你是蠢驴的舔狗，你只想代理启动蠢驴的游戏，只需要修改一处代码GameFactory gameFactory = new CDProjektRed(); 就可以一键设置为蠢驴游戏全家桶，对于客户端来说，它们并不知道自己会启动哪个厂商的游戏，因为这对它们是透明的，客户端只知道自己启动了RPGGame和CardGame. 如果哪天你又变成暴雪舔狗了，也只需要改动一处代码，客户端就会启动暴雪的游戏族。</p><p>参考资料：</p><ul><li><a href="https://blog.csdn.net/qazwsxpcm/article/details/81141325" target="_blank" rel="noopener">https://blog.csdn.net/qazwsxpcm/article/details/81141325</a></li><li>《大话设计模式》</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;设计模式有3大类，分为：&lt;strong&gt;创建型模式&lt;/strong&gt;、&lt;strong&gt;结构型模式&lt;/strong&gt;和&lt;strong&gt;行为型模式&lt;/strong&gt;。工厂模式属于创建型模式，创建型模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="DesignPatterns" scheme="http://yoursite.com/tags/DesignPatterns/"/>
    
  </entry>
  
  <entry>
    <title>初始Netty —— 实现简单的C/S通信</title>
    <link href="http://yoursite.com/2019/04/28/first_Netty/"/>
    <id>http://yoursite.com/2019/04/28/first_Netty/</id>
    <published>2019-04-28T12:08:33.730Z</published>
    <updated>2019-04-29T11:02:27.785Z</updated>
    
    <content type="html"><![CDATA[<p>写在前面：<br>Netty是Java的网络编程框架，既然是框架的学习，不免会碰到很多分支的知识和不熟悉的名词。这就需要不断的做“下潜”，耐心搜索，不求甚解，等到大致熟悉之后再去逐一深究。因此有些概念作者也不能做出详细解释，请参考贴出的相关文章或自行搜索以解决疑惑。<br><a id="more"></a></p><h3 id="什么是Netty"><a href="#什么是Netty" class="headerlink" title="什么是Netty"></a>什么是Netty</h3><p>网上很多文章都有作解释。以作者的使用体验来说，Netty是封装了 Java socket nio 来进行网络编程的工具。说到网络编程，大二软工的软件工程实训就有这个小课题，当时作者是用Java socket io来写，还没用到nio呢，就是参照网上的例子手动模拟通信过程，自己用最简单的 <strong>阻塞I/O</strong> 的模式写了一个Thread类来处理所有不同种类的请求，由于需求简单，尚能完成。 想要模拟效果更自然一点就要用 <strong>非阻塞I/O</strong> 模式，而nio就是用来写非阻塞I/O的api。但是nio的编写对java程序员是有比较高的要求的。Netty就可以简化这一系列操作。<br><!--more--></p><h3 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h3><p>贴几个比较靠谱的博客，不求甚解，大致了解一下就好。<br>关于NIO：<br><a href="https://www.jianshu.com/p/3cec590a122f" target="_blank" rel="noopener">https://www.jianshu.com/p/3cec590a122f</a>  (推荐，也包括I/O模型)<br><a href="https://my.oschina.net/andylucc/blog/614295" target="_blank" rel="noopener">https://my.oschina.net/andylucc/blog/614295</a><br>关于I/O模型：<br><a href="https://segmentfault.com/a/1190000003063859" target="_blank" rel="noopener">https://segmentfault.com/a/1190000003063859</a></p><h3 id="开发环境"><a href="#开发环境" class="headerlink" title="开发环境"></a>开发环境</h3><p>java JDK1.8 + IDEA + maven + Netty 4.1.6<br>maven依赖：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">           &lt;groupId&gt;io.netty&lt;/groupId&gt;</span><br><span class="line">           &lt;artifactId&gt;netty-all&lt;/artifactId&gt;</span><br><span class="line">           &lt;version&gt;4.1.6.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p><h3 id="实现功能"><a href="#实现功能" class="headerlink" title="实现功能"></a>实现功能</h3><p>C/S通信：C是客户端，S是服务端。在IDEA控制台开启服务端接收客户端的信息String, 并返回一个“hi!”+String，客户端收到服务端的信息后在控制台上输出。</p><h3 id="代码讲解"><a href="#代码讲解" class="headerlink" title="代码讲解"></a>代码讲解</h3><p>分为服务端和客户端两部分，各自又有一个处理连接逻辑的代码</p><h4 id="服务端代码"><a href="#服务端代码" class="headerlink" title="服务端代码"></a>服务端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.ServerBootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelFuture;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelInitializer;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelPipeline;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.EventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;  <span class="comment">//1.设置服务端端口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoServer</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();  <span class="comment">//2.创建 EventLoopGroup</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 客户端的是Bootstrap，服务端的则是    ServerBootstrap。</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            ServerBootstrap sbs = <span class="keyword">new</span> ServerBootstrap();  <span class="comment">//3.创建 ServerBootstrap</span></span><br><span class="line">            sbs.group(group)</span><br><span class="line">                    .channel(NioServerSocketChannel.class)  <span class="comment">//4.指定使用 NIO 的传输 Channel</span></span><br><span class="line">                    .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline ph = ch.pipeline();</span><br><span class="line">                            <span class="comment">/*</span></span><br><span class="line"><span class="comment">                            * Netty中的编码/解码器，通过他你能完成字节与pojo、pojo与pojo的相互转换，</span></span><br><span class="line"><span class="comment">                            * 从而达到自定义协议的目的。</span></span><br><span class="line"><span class="comment">                            * 下面是以("\n")为结尾分割的 解码器</span></span><br><span class="line"><span class="comment">                            * */</span></span><br><span class="line">                            ph.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">8192</span>, Delimiters.lineDelimiter()))</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())  <span class="comment">//解码和编码，应和客户端一致</span></span><br><span class="line">                                    .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> EchoServerHandler());  <span class="comment">//5.添加 EchoServerHandler 到 Channel 的 ChannelPipeline</span></span><br><span class="line"></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line"></span><br><span class="line">            ChannelFuture cf = sbs.bind(<span class="keyword">this</span>.port).sync();  <span class="comment">//6.设置socket地址使用所选的端口 并且 绑定的服务器，sync 等待服务器关闭</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"服务端启动成功..."</span>);</span><br><span class="line"></span><br><span class="line">            cf.channel().closeFuture().sync();  <span class="comment">//7.关闭 channel 和 块，直到它被关闭</span></span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();  <span class="comment">//8.关闭 EventLoopGroup，释放所有资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoServer(<span class="number">65535</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这一段代码：<br><img src="http://blog.duohuo.org/wp-content/uploads/2019/01/2d5cd63552e26e1c12d11902c2a05bdc.png" alt><br>这是关键所在，其余代码基本上是套路代码，按部就班写就可以。<br>关键在于此处出现了：</p><ul><li>用ChannelPipeline引用了SocketChannel的pipeline，原因在于ChannelPipeline是用于存放ChannelHandler的容器，而接下来的解码编码操作和自定义的逻辑处理类都要涉及到ChannelHandler的子类<br>它们之间的关系可以用下图表示：</li></ul><p><img src="http://blog.duohuo.org/wp-content/uploads/2019/01/27d52ce0891ede08b68a32fcc9281ae2.png" alt></p><ul><li><p>Encoder(编码器)和Decoder(解码器)，属于Codec框架的内容，大致意思是：此处描述了服务端和客户端之间传输了什么类型的数据，这里要传输String就用到了StringDecoder/Encode   当然也可以传输其他类型的数据，详情参考这篇博客：<a href="https://www.jianshu.com/p/fd815bd437cd" target="_blank" rel="noopener">https://www.jianshu.com/p/fd815bd437cd</a></p></li><li><p>注释5.处的EchoServerHandler是自定义的类，可以看作是一种“规则”，规定了服务端以什么方式处理客户端发来的数据。</p></li></ul><h4 id="服务端处理连接的代码"><a href="#服务端处理连接的代码" class="headerlink" title="服务端处理连接的代码"></a>服务端处理连接的代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.net.InetAddress;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.ChannelHandlerContext;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.SimpleChannelInboundHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 收到消息时，返回信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, String msg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"服务端接受的消息 : "</span> + msg);  <span class="comment">// 收到消息直接打印输出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"quit"</span>.equals(msg))&#123;  <span class="comment">//服务端断开的条件</span></span><br><span class="line">            ctx.close();</span><br><span class="line">        &#125;</span><br><span class="line">        ctx.writeAndFlush(<span class="string">"hi! "</span>+msg+<span class="string">"\n"</span>);  <span class="comment">// 返回客户端消息</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 建立连接时，返回消息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"连接的客户端地址:"</span> + ctx.channel().remoteAddress());</span><br><span class="line">        ctx.writeAndFlush(<span class="string">"客户端"</span>+ InetAddress.getLocalHost().getHostName() + <span class="string">"成功与服务端建立连接！ \n"</span>);</span><br><span class="line">        <span class="keyword">super</span>.channelActive(ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端代码"><a href="#客户端代码" class="headerlink" title="客户端代码"></a>客户端代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io.netty.bootstrap.Bootstrap;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.*;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.nio.NioEventLoopGroup;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.channel.socket.nio.NioSocketChannel;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.DelimiterBasedFrameDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.Delimiters;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringDecoder;</span><br><span class="line"><span class="keyword">import</span> io.netty.handler.codec.string.StringEncoder;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String host;  <span class="comment">//ip地址</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> port;     <span class="comment">//端口</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(<span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">"localhost"</span>, port);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EchoClient</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line">         <span class="keyword">this</span>.host = host;</span><br><span class="line">         <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        EventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();  <span class="comment">//1.创建 EventLoopGroup</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * Netty创建全部都是实现自AbstractBootstrap。</span></span><br><span class="line"><span class="comment">             * 客户端的是Bootstrap，服务端的则是    ServerBootstrap。</span></span><br><span class="line"><span class="comment">             **/</span></span><br><span class="line">            Bootstrap bs = <span class="keyword">new</span> Bootstrap();  <span class="comment">//2.创建 Bootstrap</span></span><br><span class="line"></span><br><span class="line">            System.out.println(<span class="string">"客户端成功启动..."</span>);</span><br><span class="line"></span><br><span class="line">            bs.group(group)  <span class="comment">//3.指定 NioEventLoopGroup 来处理客户端事件。</span></span><br><span class="line">                    .channel(NioSocketChannel.class)</span><br><span class="line">                    .handler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;  <span class="comment">//4.指定使用 NIO 的传输 Channel</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ChannelPipeline ph = ch.pipeline();</span><br><span class="line">                            ph.addLast(<span class="string">"framer"</span>, <span class="keyword">new</span> DelimiterBasedFrameDecoder(<span class="number">8192</span>, Delimiters.lineDelimiter()))</span><br><span class="line">                                    .addLast(<span class="string">"decoder"</span>, <span class="keyword">new</span> StringDecoder())</span><br><span class="line">                                    .addLast(<span class="string">"encoder"</span>, <span class="keyword">new</span> StringEncoder())  <span class="comment">// 解码和编码，应和服务端一致</span></span><br><span class="line">                                    .addLast(<span class="string">"handler"</span>, <span class="keyword">new</span> EchoClientHandler());  <span class="comment">//5.当建立一个连接和一个新的通道时，创建添加到 EchoClientHandler 实例 到 channel pipeline</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">            Channel ch = bs.connect(<span class="keyword">this</span>.host, <span class="keyword">this</span>.port).sync().channel();  <span class="comment">//6.设置服务器的ip和端口，并且连接到远程; 等待连接完成</span></span><br><span class="line"></span><br><span class="line">            Scanner in=<span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"请输入要发送的信息："</span>);</span><br><span class="line">                String str=in.next();</span><br><span class="line">                <span class="comment">//连接后发送数据</span></span><br><span class="line">                ch.writeAndFlush(str+ <span class="string">"\r\n"</span>);</span><br><span class="line">                System.out.println(<span class="string">"客户端发送数据:"</span>+str);</span><br><span class="line">                <span class="keyword">if</span> (str.equals(<span class="string">"quit"</span>))<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();  <span class="comment">//8.关闭线程池和释放所有资源</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> EchoClient(<span class="string">"127.0.0.1"</span>, <span class="number">65535</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端和服务端代码样式基本一致，有几个关键点都已注释<br><img src="http://blog.duohuo.org/wp-content/uploads/2019/01/cefccb1c91e7593d6278109de2c6a89f.png" alt><br>此处以不断向客户端发送信息，输入“quit”终止连接。</p><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>先运行服务端再运行客户端<br>服务端：<br><img src="http://blog.duohuo.org/wp-content/uploads/2019/01/781c5efd2db39cccd9f49ba70af253bc.png" alt><br>客户端1:<br><img src="http://blog.duohuo.org/wp-content/uploads/2019/01/6288b3985b7af37895fcf2f1b63be69a.png" alt><br>客户端2：<br><img src="http://blog.duohuo.org/wp-content/uploads/2019/01/3db8b4f3bc3dd1ce8d37dcc875dfc5c9.png" alt></p><h3 id="参考文章："><a href="#参考文章：" class="headerlink" title="参考文章："></a>参考文章：</h3><p><a href="https://www.cnblogs.com/liuming1992/p/4758532.html" target="_blank" rel="noopener">https://www.cnblogs.com/liuming1992/p/4758532.html</a><br><a href="https://blog.csdn.net/qazwsxpcm/article/details/77750865" target="_blank" rel="noopener">https://blog.csdn.net/qazwsxpcm/article/details/77750865</a><br><a href="https://www.jianshu.com/p/b9f3f6a16911" target="_blank" rel="noopener">https://www.jianshu.com/p/b9f3f6a16911</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;写在前面：&lt;br&gt;Netty是Java的网络编程框架，既然是框架的学习，不免会碰到很多分支的知识和不熟悉的名词。这就需要不断的做“下潜”，耐心搜索，不求甚解，等到大致熟悉之后再去逐一深究。因此有些概念作者也不能做出详细解释，请参考贴出的相关文章或自行搜索以解决疑惑。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot使用slf4j+logback配合AOP做日志记录</title>
    <link href="http://yoursite.com/2019/04/28/SpringBoot_logger_AOP/"/>
    <id>http://yoursite.com/2019/04/28/SpringBoot_logger_AOP/</id>
    <published>2019-04-28T11:42:06.303Z</published>
    <updated>2019-04-29T11:02:59.046Z</updated>
    
    <content type="html"><![CDATA[<p>需要大致了解：java日志基础，如核心组件Loggers,Appenders,Layouts的用处、SpringAOP概念</p><h3 id="为什么需要日志"><a href="#为什么需要日志" class="headerlink" title="为什么需要日志"></a>为什么需要日志</h3><p>当应用程序部署到服务器上运行时，用户在使用过程中可能会出现各种错误。这时应用程序将错误信息生成日志，就方便了开发人员快速定位错误和根源，从而进行有针对的维护。所以，在大型应用程序中，日志记录是必不可少的。<br><a id="more"></a></p><h3 id="选择日志框架"><a href="#选择日志框架" class="headerlink" title="选择日志框架"></a>选择日志框架</h3><p>目前市面上可供选择的日志框架非常多，如JCL、SLF4J、Jboss-logging、jUL、log4j、log4j2、logback等，首先要分清楚 [日志抽象层] 和 [日志实现]。   这两者的关系可以参考设计模式中的“门面模式”。  我们在开发中调用日志记录方法时，不应直接调用日志实现类的方法，而是调用日志抽象层的方法。这样方便解耦，以后想更换别的日志实现时，可以直接改动配置文件的信息，<strong>而不用修改一行代码</strong>。 那么如何选择日志框架呢？</p><ul><li>日志抽象层：JCL（Jakarta Commons Logging), SLF4j（Simple Logging Facade for Java）, jboss-logging</li><li>日志实现：Log4j, JUL（java.util.logging）, Log4j2,  Logback</li></ul><p>关于如何选择网络上有很多文章分析，在此不赘述。结论就是SLF4J更受开发者青睐，事实上《阿里java开发手册》上也规定：<em>应用中不可直接使用日志系统（Log4j、Logback）中的API，而应依赖使用日志框架<br>SLF4J中的API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</em><br>至于选择日志实现，log4j是很常用的，但其作者又写了log4j的升级版logback，相比log4j有更好的性能。有诸多理由让我们选择logback，使用好logback关键的一点就是配置好logback.xml文件，可参阅<a href="https://www.cnblogs.com/warking/p/5710303.html" title="logback使用和配置详解" target="_blank" rel="noopener">logback使用和配置详解</a></p><h4 id="maven引入"><a href="#maven引入" class="headerlink" title="maven引入"></a>maven引入</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>ch.qos.logback<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>logback-classic<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>SpringBoot已默认使用slf4j和logback  无需引入对应依赖。</strong></p><h3 id="如何插入日志记录"><a href="#如何插入日志记录" class="headerlink" title="如何插入日志记录"></a>如何插入日志记录</h3><p>使用SpringAOP，目的是让开发者专注于业务逻辑而无需关心在哪里插入日志，并且可以降低日志记录操作对业务代码的侵入性。<br>这里我们使用 AspectJ 的几个注解来写一个切面类TestAspect.java<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demo.annotation.RequestColor;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"testAspect"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAspect</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(TestAspect.class); </span><br><span class="line">    <span class="comment">//controller包切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.example.demo.controller.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">controllerPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//TestController切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.example.demo.controller.TestController.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testControllerPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//具体方法 ayahiro 切点</span></span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.example.demo.controller.TestController.ayahiro()))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ayahiroPointCut</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Before</span>(value = <span class="string">"testControllerPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doBefore</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"form: TestAspect----&gt;&gt;"</span>);</span><br><span class="line">        String className=joinPoint.getSignature().getDeclaringTypeName();</span><br><span class="line">        String methodName=joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"doBefore拦截了"</span>+className+<span class="string">"."</span>+methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@After</span>(value = <span class="string">"@annotation(requestColor)"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfter</span><span class="params">(JoinPoint joinPoint, <span class="keyword">final</span> RequestColor requestColor)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"form: TestAspect----&gt;&gt;"</span>);</span><br><span class="line">        String className=joinPoint.getSignature().getDeclaringTypeName();</span><br><span class="line">        String methodName=joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"doAfter拦截了"</span>+className+<span class="string">"."</span>+methodName);</span><br><span class="line">        System.out.println(<span class="string">"requestType: "</span>+ requestColor.type());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Around</span>(value = <span class="string">"ayahiroPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doAround</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        Object re=joinPoint.proceed();  <span class="comment">//执行了ayahiro方法  返回了String</span></span><br><span class="line">        System.out.println(re);</span><br><span class="line">        System.out.println(<span class="string">"form: TestAspect----&gt;&gt;"</span>);</span><br><span class="line">        String className=joinPoint.getSignature().getDeclaringTypeName();</span><br><span class="line">        String methodName=joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"doAround拦截了"</span>+className+<span class="string">"."</span>+methodName);</span><br><span class="line">        <span class="keyword">return</span> re;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterReturning</span>(value = <span class="string">"testControllerPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterReturning</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"form: TestAspect----&gt;&gt;"</span>);</span><br><span class="line">        String className=joinPoint.getSignature().getDeclaringTypeName();</span><br><span class="line">        String methodName=joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"doAfterReturning拦截了"</span>+className+<span class="string">"."</span>+methodName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(value = <span class="string">"testControllerPointCut()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doAfterThrowing</span><span class="params">(JoinPoint joinPoint)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"form: TestAspect----&gt;&gt;"</span>);</span><br><span class="line">        String className=joinPoint.getSignature().getDeclaringTypeName();</span><br><span class="line">        String methodName=joinPoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">"doAfterThrowing拦截了"</span>+className+<span class="string">"."</span>+methodName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以及Controller，有两个返回字符串的测试方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> com.example.demo.annotation.RequestColor;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestColor</span>(type = RequestColor.Type.YELLOW)</span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/ayahiro"</span>&#125;,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">ayahiro</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//int num=2/0;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this ayahiro"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = &#123;<span class="string">"/moonKa"</span>&#125;,method = &#123;RequestMethod.GET&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">moonKa</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"this moonKa"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="介绍几个常用的注解"><a href="#介绍几个常用的注解" class="headerlink" title="介绍几个常用的注解"></a>介绍几个常用的注解</h3><ul><li>@Aspect 表明这个类是“切面类”，切面类就是用来定义切点和切点处要增强功能的方法</li><li>@Pointcut 这个注解包含两部分，PointCut表达式和PointCut签名。表达式是用来确定切入点的位置的，说白了就是通过一些规则来确定，哪些方法是要增强的，也就是要拦截哪些方法。注解括号里的部分就是描述切点的位置，有很多种方法来确定，代码中使用的execution表达式是其中的一种，其语法和其他描述方法可自行百度。 签名就是被注解的方法名，签名没有实际用处，只是用来标记一个Pointcut，可以理解成这个切入点的一个记号。</li><li>@Before 顾名思义，即在切入点处方法执行前，执行此方法。同下面的@After，@Around，@AfterReturning， @AfterThrowing注解类似，都是规定了在何时(相对于待增强方法)执行被注解的方法。只不过注解属性有所区别</li><li>JoinPoint 代表着织入增强处理的连接点。注意一点：除了注解@Around的方法外，其他都可以加这个JoinPoint作参数，@Around注解的方法的参数一定要是ProceedingJoinPoint。 JoinPoint包含了几个很有用的参数：<ul><li>Object[] getArgs：返回目标方法的参数</li><li>Signature getSignature：返回目标方法的签名</li><li>Object getTarget：返回被织入增强处理的目标对象</li><li>Object getThis：返回AOP框架为目标对象生成的代理对象</li></ul></li></ul><h3 id="运行效果"><a href="#运行效果" class="headerlink" title="运行效果"></a>运行效果</h3><p>理解了几个注解的作用后，通过运行结果，来看看测试方法都被哪些增强方法拦截了<br>启动后，在浏览器输入<a href="http://localhost:8080/ayahiro" target="_blank" rel="noopener">http://localhost:8080/ayahiro</a><br><img src="http://blog.duohuo.org/wp-content/uploads/2019/03/捕获-300x107.png" alt><br>可以看到，ayahiro()被所有增强方法拦截了。testControllerPointCut()和ayahiroPointCut()拦截不难理解，都前者是划定了一个范围，后者是直接具体定位到该方法。其中@After(value = “@annotation(requestColor)”) 的拦截方式比较特别，是通过自定义注解拦截的，因为ayahiro()被@RequestColor修饰，而@After拦截所有被@RequestColor修饰的方法。<br>输入<a href="http://localhost:8080/moonKa" target="_blank" rel="noopener">http://localhost:8080/moonKa</a><br><img src="http://blog.duohuo.org/wp-content/uploads/2019/03/捕获2-300x49.png" alt><br>可以看到@After就没有拦截moonKa方法，因为该方法没有被@RequestColor修饰。</p><h3 id="使用日志！"><a href="#使用日志！" class="headerlink" title="使用日志！"></a>使用日志！</h3><p>理解了AOP的思想之后，再结合slf4j记录日志就显得非常简单，调用日志方法只需要声明一个 private static final Logger logger = LoggerFactory.getLogger(当前类.class);  再用loger去调用具体的方法：.info()  .warn()  .debug() .error()即可~</p><p>参考资料：<br>    <a href="https://www.cnblogs.com/wangshen31/p/9379197.html" target="_blank" rel="noopener">https://www.cnblogs.com/wangshen31/p/9379197.html</a><br>    <a href="https://blog.csdn.net/caychen/article/details/80112915" target="_blank" rel="noopener">https://blog.csdn.net/caychen/article/details/80112915</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;需要大致了解：java日志基础，如核心组件Loggers,Appenders,Layouts的用处、SpringAOP概念&lt;/p&gt;
&lt;h3 id=&quot;为什么需要日志&quot;&gt;&lt;a href=&quot;#为什么需要日志&quot; class=&quot;headerlink&quot; title=&quot;为什么需要日志&quot;&gt;&lt;/a&gt;为什么需要日志&lt;/h3&gt;&lt;p&gt;当应用程序部署到服务器上运行时，用户在使用过程中可能会出现各种错误。这时应用程序将错误信息生成日志，就方便了开发人员快速定位错误和根源，从而进行有针对的维护。所以，在大型应用程序中，日志记录是必不可少的。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2019/04/25/hello-world/"/>
    <id>http://yoursite.com/2019/04/25/hello-world/</id>
    <published>2019-04-25T12:16:47.537Z</published>
    <updated>2019-04-29T11:03:14.446Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2019/04/25/hello-world/桌面.jpg" alt="测试图片功能"><br>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.<br><a id="more"></a></p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2019/04/25/hello-world/桌面.jpg&quot; alt=&quot;测试图片功能&quot;&gt;&lt;br&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
